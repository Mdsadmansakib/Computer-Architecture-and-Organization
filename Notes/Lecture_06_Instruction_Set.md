
# Lecture 06: Classifying Instruction Set

> **Credit:** Based on content from *Lecture 06 (Classifying Instruction Set)* of the DBMS course materials.

---

## 1. CISC vs RISC

### CISC (Complex Instruction Set Computer)
- Employs a large number of instructions.
- Instructions can perform multiple low-level operations.
- Often uses variable-length instructions and multiple addressing modes.
- Designed to minimize the number of instructions per program.

### RISC (Reduced Instruction Set Computer)
- Emphasizes a smaller set of instructions that are optimized for high performance.
- Instructions typically have uniform length and format.
- Employs a load/store architecture where only load and store access memory.
- Simplifies hardware and enables pipelining.

| Feature                  | CISC                          | RISC                          |
|--------------------------|-------------------------------|-------------------------------|
| Instruction Complexity   | High                          | Low                           |
| Instruction Length       | Variable                      | Fixed                         |
| Memory Access            | Multiple instructions support | Only load/store               |
| Execution Time           | Multi-cycle                   | Single-cycle                  |

---

## 2. Instruction Format

Instructions in a processor include:
- An opcode (operation code)
- Operand(s): registers or memory locations

**RISC Format Example:**
```
Rd := F(Rs, S2)
```
Where:
- `Rd`: Destination register
- `Rs`: Source register
- `S2`: Can be a register or immediate value

Bit allocation:
- Opcode: bits 31–23
- Source Rs: bits 18–12
- Destination Rd: varies
- S2: either register or immediate value

---

## 3. Operand Extension

### Sign Extension:
- Used with signed values (two’s complement).
- Sign bit is replicated when increasing operand size.

**Example:** 13-bit `1010101010101` → 32-bit `11111111111111111111010101010101`

### Zero Extension:
- Used with unsigned values.
- Zeroes are added to the left.

**Example:** 13-bit `1010101010101` → 32-bit `00000000000000000001010101010101`

---

## 4. Address Extension

Addresses in memory can be generated by:
```
Effective Address = Base Register (Rd) + Offset (S2)
```

**Example Instruction:**
```
STB Rs, Rd(S2)
```
Performs: `M[Rd+S2] := Rs[24:31]`

---

## 5. Addressing Modes

### Immediate Addressing:
Operand is directly specified in the instruction.
```
MVI A, 99
```

### Direct Addressing:
Address field refers directly to the memory location.
```
MOV A, B
```

### Indirect Addressing:
The address refers to another memory location that contains the effective address.
```
LOADN W → AC := M[M[W]]
```

### Relative Addressing:
Effective address = Base + Offset

Used for:
- Code relocation
- Array accesses

### Auto Indexing:
Automatically increments or decrements address values used in array accesses.

---

## Exercises

### Q1. Differentiate between RISC and CISC with 3 points.
**Answer:**
- RISC uses fixed-length instructions; CISC uses variable-length.
- RISC allows only load/store memory access; CISC supports memory operands in many instructions.
- RISC generally executes instructions in one clock cycle; CISC may require multiple cycles.

---

### Q2. Perform sign and zero extension for the binary number `1010101010101` (13-bit) to 32-bit.

**Sign Extension:**
```
Leftmost bit = 1 → replicate 1
Result: 11111111111111111111010101010101
```

**Zero Extension:**
```
Pad with 0s to the left
Result: 00000000000000000001010101010101
```

---

### Q3. What is the effective address for `STB Rs, Rd(S2)` when Rd = 0x1000 and S2 = 0x20?

**Answer:**
```
Effective Address = Rd + S2 = 0x1000 + 0x20 = 0x1020
```

---

### Q4. Identify the addressing mode used:
- `MOV A, #5` → **Immediate Addressing**
- `MOV A, B` → **Direct Addressing**
- `MOV A, [B]` → **Indirect Addressing**

---

### Q5. Why is relative addressing beneficial for loops or arrays?

**Answer:**
- Enables compact encoding.
- Code can be relocated in memory.
- Simplifies addressing with offsets for array elements.

---
